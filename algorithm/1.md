
// 1-1 简介
理论
数据结构：
1. 栈
1. 队列
1. 集合
1. 链表
1. 字典
1. 树
1. 图
1. 堆

进阶算法：
1. 冒泡算法
1. 选择算法
1. 插入算法
1. 归并算法
1. 快速算法
1. 顺序算法
1. 二分搜索

算法设计思想
1. 分而治之
1. 动态规划
1. 贪心
1. 回溯

重点：数据结构算法特点、应用场景、JS实现、时间/空间复杂度

刷题：
1. 刷题网站：推荐LeetCode
1. 刷题顺序：推荐按照类型刷题，集中训练
重点：通用套路，时间/控件复杂度分析和优化

实战
1. 前端与数据结构/算法的结合点
1. 工作中与数据结构/算法打交道


// 1-2 数据结构/算法

栈、队列、链表
集合、字典
链接关系：树、堆、图

链表：遍历、删除链表节点
树、堆、图：深度/广度优化遍历
数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索

// 1-3 Leetcode

// 2-1 时间复杂度计算
1. 函数 用大O表示 O(1) O(logN) O(n) O(n2)
1. 定性描述该算法的运行时间（不会描述具体多少秒，大概运行时间的趋势）

图

O(1) 
let i = 0
i += 1
1. 声明变量i 初始化值0
1. 执行 i = i+1
每次执行代码文件，永远只会执行一次，没有循环，所以时间复杂度O（1）

O(n)
for(let i=0; i< n; i +=1){
  console.log(i)
}

O(1)+O(n) = O(n)
let i = 0
i += 1
for(let j=0; j< n; j +=1){
  console.log(j)
}

O(n)*O(n)=O(n^2)
for(let i= 0; i<n; i+=1){
  for(let j=0; j<m; j+=1){
    console.log(i, j)
  }
}

O(logN)
let i = 1
while(i < n){
  console.log(i)
  i *= 2
}

// 2-2 空间复杂度
1. 函数 O(1) O(n) O(n^2)
1. 算法在运行过程中临时占用存储空间大小的度量

O(1)
let i = 0
i += 1
只声明单个变量，单个变量所占有的内存永远是1，永远是恒定的内存

O(n)
const list = []
for(let i=0; i<n; i+=1){
  list.push(i)
}

O(n^2) 矩阵
const matrix = []
for(let i= 0; i<n; i+=1){
  matrix.push([])
  for(let j=0; j<m; j+=1){
    matrix[i].push(j)
  }
}